列表反转，反转两次得到结果

利用map存储折半的数据，如何求list中有没有两个数相加得到固定的值

贪心算法，每次只计算两个，用过即丢,股票的案例   
贪心算法的含义是每一步都取出最优选，然后一步一步向下走

检查列表是否有环，
利用快慢指针

将链表彻底反转  
配置好数据结构之后，利用三个变量完成链表的反转

排序算法   
快速和合并的时间复杂度都是nlogn，
冒泡，选择，插入，时间复杂度都是n^2
冒泡的灵魂就是从小到大，选出最大值，两个的最大值，然后一步一步一次循环一个最大值，
选择的灵魂是最符合我的逻辑的，使用一个变量承载最大值，不断变换，
插入排序的灵魂是位移，复制两个，不断位移，直到找到合适的位置，

数据结构里面的算法
最短路径，好熟悉的概念，但是我查了为知笔记，没有这个概念   
难道真的只有图里面才有这个概念吗？

超平衡二叉树里面的灵魂，   
那就是stack在循环里面不断增加，这个是我看到图的广度优先算法想到的，因为广度优先算法就是不断的向栈里面添加数据
不对啊，广度优先算法使用的是队列，并不是栈
如果使用java中的list实现的话，那就是从前面出还是从后面出的问题，如果从末尾出的话，那就是后进先出，就是栈，如果是
第一个出的话，那就是先进先出，这就是队列
广度优先算法中，有一个先判断是否已经检查的代码，也就是在判断判断这个人是否是芒果商之前会先判断一次是否已经
检查了，如果已经检查了，那就不会执行下面的逻辑

如果图有权重的话，那就使用狄克斯特拉算法求解最短路径
这个算法的灵魂是，
先找出开销最小的点，连起来，（和贪心算法有点相似）然后，这两个点就是一个整体了，不断更新经过B点前往周围邻居的
的开销
官方的说法是这样的：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径